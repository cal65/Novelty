import os
import re
import warnings
import argparse
from pandas.api.types import is_numeric_dtype, CategoricalDtype
import pandas as pd
import numpy as np
import geopandas as gpd

import plotly
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
from plotly.subplots import make_subplots

from spotify.plotting.utils import standard_layout, save_fig, objects_to_df, write_text
from goodreads.models import RefNationality, Books, Authors, ExportData

import logging

warnings.simplefilter(action="ignore", category=FutureWarning)

logging.basicConfig(
    filename="logs.txt",
    filemode="a",
    format="%(asctime)s %(levelname)-8s %(message)s",
    level=logging.INFO,
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

post_pass = os.getenv("cal65_pass")

# global color palette
palette = plotly.colors.qualitative.Plotly


def load_data(username):
    export_df = objects_to_df(ExportData.objects.filter(username=username))
    books_df = objects_to_df(Books.objects.filter(book_id__in=export_df["book_id"]))
    authors_df = objects_to_df(
        Authors.objects.filter(author_name__in=export_df["author"])
    )
    authors_df.rename(columns={"author_name": "author"}, inplace=True)
    authors_df.drop(columns="ts_updated", inplace=True)
    books_df.drop(columns="ts_updated", inplace=True)
    df = pd.merge(export_df, books_df, how="left", on="book_id")
    df = pd.merge(df, authors_df, how="left", on="author")
    return df


def preprocess(df):
    gender_dict = {"mostly_male": "male", "mostly_female": "female"}
    df["gender"] = df["gender"].map(gender_dict).fillna(df["gender"])
    df["date_read"] = pd.to_datetime(df["date_read"])
    df["title_simple"] = df["title"].str.replace(":.*", "")
    df["title_simple"] = df["title_simple"].str.replace("\\(.*\\)", "")
    df["title_simple"] = df["title_simple"].str.strip()
    df["author"] = df["author"].apply(lambda x: re.sub(r"\s+", " ", x))
    return df


def narrative(df):
    shelf_columns = [s for s in df.columns if s.startswith("shelf")]
    df["narrative"] = df[shelf_columns].apply(
        lambda x: "Nonfiction" if "Nonfiction" in x.values else "Fiction", axis=1
    )
    return df


def read_percentage(df):
    # It seems sometimes the "added by" value is off by a factor of 10. When the
    # number of people listing the book as "to read" is larger than total added by, multiply by 10
    df.loc[df["to_reads"] > df["added_by"], "added_by"] = (
        df.loc[df["to_reads"] > df["added_by"], "added_by"] * 10
    )
    df["read"] = df["added_by"] - df["to_reads"]
    df["read_percentage"] = df["read"] / df["added_by"]
    return df


def run_all(df):
    df = read_percentage(narrative(preprocess(df)))
    return df


def generate_labels(breaks):
    """
    For the read plot function
    Get list of breaks generated by cut function.
    Return a list of strings with the break marks
    """

    if len(breaks) == 2:
        return [f"{breaks[0]} - {breaks[1]}"]
    else:
        return [f"{breaks[0]} - {breaks[1]}"] + generate_labels(breaks[1:])


def strat_count(df, col, min_break=3, opt_labels=None):
    """
    Take a dataframe and a column, and minimum digits in last break
    Divide column into strats of powers of ten, starting from 10^min_break
    """
    df.sort_values(col, ascending=True, inplace=True)
    col_max = int(df[col].max())
    max_digits = len(str(col_max))
    digit_range = list(range(min_break, max_digits + 1))
    breaks = [0] + [10**d for d in digit_range]
    # ['0 - 1,000', '1,000 - 10,000', '10,000 - 100,000', '100,000 - 1,000,000'] using fancy local-aware f:, hack
    break_labels = generate_labels([f"{b:,}" for b in breaks])
    if opt_labels is not None:
        if len(opt_labels) != 2:
            raise Exception("labels must be of length 2")
        else:
            break_labels[0] = f"{break_labels[0]} <br> {opt_labels[0]}"
            break_labels[-1] = f"{break_labels[-1]} <br> {opt_labels[1]}"
    df["strats"] = pd.cut(
        df[col], bins=breaks, labels=break_labels, include_lowest=True
    )
    return df


def read_plot_munge(
    df,
    read_col="read",
    min_break=3,
    date_col="date_read",
    start_year=2010,
):
    df = df[pd.notnull(df[read_col])]
    if len(df) == 0:
        return df
    if start_year is not None:
        df = df[df[date_col].dt.year >= start_year]
    df = strat_count(
        df, col="read", min_break=min_break, opt_labels=["Obscure", "Bestsellers"]
    )
    # logging
    strats_count = df["strats"].value_counts()
    logger.info(f"debugging read plot munge: {strats_count}")
    return df


def factorize(series):
    # order numeric series from low to high
    uniques = pd.unique(series)
    if is_numeric_dtype(series):
        uniques = sorted(uniques)

    # take a series, return it as an ordered category typed series
    cat_type = CategoricalDtype(categories=uniques, ordered=True)
    series = series.astype(cat_type)
    return series


def finish_plot(
    df,
    username,
    exclusive_shelf="exclusive_shelf",
    read_col="read_percentage",
    title_col="title_simple",
    n=10,
):
    df[exclusive_shelf] = df[exclusive_shelf].replace(
        {"currently-reading": "unread", "to-read": "unread"}
    )
    df[title_col] = df[title_col].apply(split_title)

    df_finish = df.loc[pd.notnull(df[read_col])].sort_values(read_col)
    df_finish["original_publication_year"] = df_finish[
        "original_publication_year"
    ].fillna("Unknown")
    df_finish_read = df_finish.loc[df_finish["exclusive_shelf"] == "read"]
    df_finish_unread = df_finish.loc[df_finish["exclusive_shelf"] != "read"]

    def finish_bar_flat(df1):
        return go.Bar(
            x=[1] * len(df),
            y=df1[title_col],
            orientation="h",
            customdata=df1["added_by"].apply(lambda x: f"{int(x):,}"),
            marker_color=palette[0],
            hovertemplate="<b>%{y}</b><br>Total Added: <b>%{customdata}</b><extra></extra>",
            width=1,
            showlegend=False,
        )

    def finish_bar_perc(df2):
        hovertemplate = "<b>%{y}</b><br>Year: <b>%{customdata[1]}</b><br>"
        hovertemplate += "Total Finished: <b>%{customdata[0]}</b><extra></extra>"
        return go.Bar(
            x=df2[read_col],
            y=df2[title_col],
            marker_color=palette[1],
            text=df2[read_col].map(lambda x: "<b>{:.1%}".format(x)),
            customdata=np.stack(
                (
                    df2["read"].apply(lambda x: f"{int(x):,}"),
                    df2["original_publication_year"],
                ),
                axis=-1,
            ),
            textposition="inside",
            textangle=0,
            hovertemplate=hovertemplate,
            textfont=dict(size=8),
            orientation="h",
            width=1,
            showlegend=False,
        )

    if len(df_finish_unread) > 0:
        fig = make_subplots(rows=2, cols=1, subplot_titles=["Read", "Unread"])
        fig.add_trace(finish_bar_flat(df_finish_read.head(n)), row=1, col=1)

        fig.add_trace(finish_bar_perc(df_finish_read.head(n)), row=1, col=1)

        fig.add_trace(finish_bar_flat(df_finish_unread.head(n)), row=2, col=1)

        fig.add_trace(finish_bar_perc(df_finish_unread.head(n)), row=2, col=1)
    else:
        fig = go.Figure()
        fig.add_trace(finish_bar_flat(df_finish_read.head(n)))
        fig.add_trace(finish_bar_perc(df_finish_read.head(n)))

    fig.update_layout(barmode="overlay", title=f"Finish Plot - {username}")
    fig.update_layout(standard_layout)
    logger.info(
        f"Debugging df_finish_read: {df_finish_read[[title_col, read_col, exclusive_shelf]].sample(2)}"
    )
    return fig


def gender_bar_plot(df, gender_col="gender", narrative_col="narrative"):
    # ignore nones
    df_gender = pd.DataFrame(
        df.groupby([gender_col, narrative_col], as_index=False).size()
    )
    traces = []
    for g in df_gender[gender_col].unique():
        df_g = df_gender.loc[df_gender[gender_col] == g]
        traces.append(
            go.Bar(
                x=df_g["size"],
                y=df_g[narrative_col],
                orientation="h",
                hovertemplate="<b>Type:</b> %{y}<br><b>Count:</b> %{x}<extra></extra> ",
                name=g,
            )
        )
    return traces


def split_title(title, n=30):
    """
    Useful function for splitting long text up between words
    """
    if len(title) < n:
        return title
    else:
        title_splits = title.split(" ")
        title_length = 0
        i = 0
        while title_length < n:
            title_length += len(title_splits[i]) + 1
            i += 1
        if i == len(title_splits):
            return title
        else:
            front = " ".join(title_splits[:i])
            back = " ".join(title_splits[i:])
            title = "<br>".join([front, back])
            return title


def len_title_pivot(df, index_cols, add_value_cols, title_col="title_simple", n=3):
    if add_value_cols is None:
        value_cols = [title_col]
    else:
        value_cols = add_value_cols + [title_col]
    df_pivot = pd.pivot_table(
        df,
        index=index_cols,
        values=value_cols,
        aggfunc=[len, lambda x: ", ".join(x[:n])],
    ).reset_index()
    return df_pivot


def publication_histogram(
    df, date_col="original_publication_year", title_col="title_simple", start_year=1800
):
    df_recent = df[df[date_col] > start_year]
    df_publication = len_title_pivot(
        df_recent, index_cols=[date_col], add_value_cols=None, title_col="title_simple"
    )
    df_publication.columns = [date_col, "n", title_col]
    return go.Bar(
        x=df_publication[date_col],
        y=df_publication["n"],
        customdata=df_publication[title_col],
        hovertemplate="<b>Year:</b> %{x}<br><b>Count:</b> %{y}<br>%{customdata}<extra></extra>",
        showlegend=False,
        name="",
    )


def plot_longest_books(
    df,
    n=15,
    pages_col="number_of_pages",
    title_col="title_simple",
):
    highest = df[pd.notnull(df[pages_col])].sort_values(pages_col).tail(n)
    highest[title_col] = highest[title_col].apply(split_title)
    highest[title_col] = factorize(highest[title_col])
    return go.Bar(
        x=highest[pages_col],
        y=highest[title_col],
        text=highest[pages_col],
        orientation="h",
        hovertemplate="<b>%{y}</b><br><b>Number of Pages:</b> %{x}<extra></extra>",
        showlegend=False,
    )


def create_melted_genre_df(df, title_col="title_simple"):
    """
    Dataframe contains multiple columns starting with 'shelf', to plot them we need to melt the shelves
    """
    shelf_columns = [s for s in df.columns if s.startswith("shelf")]
    genre_df = df[[title_col] + shelf_columns]
    genre_df_m = pd.melt(genre_df, id_vars="title_simple", value_name="Shelf")
    # Remove shelves that are not meaningful (hardcoded values)
    genre_df_m = genre_df_m[~genre_df_m["Shelf"].isin(["Fiction", "Nonfiction", "", "Audiobook"])]
    genre_df_m = genre_df_m[pd.notnull(genre_df_m["Shelf"])]
    # strip values
    genre_df_m["Shelf"] = genre_df_m["Shelf"].str.strip()
    return genre_df_m


def genre_bar_plot(df, title_col="title_simple", n_shelves=5, min_count=3):
    """
    Because genres are stored in multiple columns starting with 'shelf', to plot them we need to melt the shelves
    Currently 7 shelves are stored, but including them all can lead to a busy graph
    Default is to only show top 4
    """

    genre_df_m = create_melted_genre_df(df)
    genre_df_m["shelf_number"] = (
        genre_df_m["variable"].str.replace("shelf", "").astype(int)
    )
    genre_df_m = genre_df_m[genre_df_m["shelf_number"] <= n_shelves]
    shelf_table_df = len_title_pivot(
        genre_df_m, index_cols=["Shelf"], add_value_cols=None, title_col=title_col
    )
    shelf_table_df.columns = ["Shelf", "Count", title_col]
    shelf_table_df.sort_values("Count", ascending=False, inplace=True)
    shelf_table_df["Shelf"] = factorize(shelf_table_df["Shelf"])

    # manual adjustment for smaller datasets
    if len(df) < 75:
        min_count = 1

    plot_df = shelf_table_df[shelf_table_df["Count"] > min_count]
    plot_df = plot_df.head(25)

    return go.Bar(
        x=plot_df["Count"],
        y=plot_df["Shelf"],
        orientation="h",
        customdata=plot_df[title_col],
        hovertemplate="<b>Shelf:</b> %{y}<br><b>Count:</b> %{x}<br><b>Titles:</b> %{customdata}<extra></extra>",
        showlegend=False,
    )


def format_genre_table(df, genres_avg, n=12):
    melted_genre_df = create_melted_genre_df(df)
    genre_count = pd.pivot_table(
        melted_genre_df,
        index="Shelf",
        values="title_simple",
        aggfunc=[len, lambda x: "<br>".join(x[:3])],
    ).reset_index()
    genre_count.columns = ["Shelf", "n", "titles"]
    genre_count["Ratio_User"] = genre_count["n"] / genre_count["n"].sum() * 100
    # remove genres where you've only read 1 book, it can skew results
    genre_count = genre_count.loc[genre_count["n"] > 1]

    #
    genre_table_merged = pd.merge(genres_avg, genre_count, on="Shelf", how="outer")
    genre_table_merged["Ratio_User"] = genre_table_merged["Ratio_User"].fillna(0)
    genre_table_merged["Ratio_Total"] = genre_table_merged["Ratio_Total"].fillna(0)
    genre_table_merged["Diff"] = genre_table_merged["Ratio_User"].apply(
        np.sqrt
    ) - genre_table_merged["Ratio_Total"].apply(np.sqrt)
    genre_table_merged.sort_values("Diff", inplace=True)

    genre_difference = pd.concat(
        [genre_table_merged.head(n), genre_table_merged.tail(n)]
    )
    genre_difference["Result"] = ["Below Average"] * n + ["Above Average"] * n
    # remove Above Averages when the difference is negative. Rare occasion when user does not have many shelves
    genre_difference = genre_difference.loc[
        ~(
            (genre_difference["Result"] == "Above Average")
            & (genre_difference["Diff"] < 0)
        )
    ]

    return genre_difference


def plot_genre_difference(genre_difference, username):
    logger.info(
        f"plotting genres comparison plot for df of {len(genre_difference)} rows"
    )

    fig = make_subplots(
        1, 2, subplot_titles=["Above Average", "Below Average"], vertical_spacing=0.05
    )

    genre_above = genre_difference.loc[genre_difference["Result"] == "Above Average"]
    fig.add_trace(
        go.Bar(
            x=genre_above["Ratio_User"],
            y=genre_above["Shelf"],
            customdata=np.stack(
                (
                    genre_above["Ratio_User"].apply(lambda x: format(x / 100, ".2%")),
                    genre_above["titles"],
                ),
                axis=-1,
            ),
            orientation="h",
            name="Your Genres",
            marker=dict(color=palette[2]),
            hovertemplate="<b>%{y}</b><br><b>Ratio:</b> %{customdata[0]} <br><b>Titles:</b> %{customdata[1]}<extra></extra>",
        ),
        row=1,
        col=1,
    )
    fig.add_trace(
        go.Bar(
            x=genre_above["Ratio_Total"],
            y=genre_above["Shelf"],
            customdata=genre_above["Ratio_Total"].apply(
                lambda x: format(x / 100, ".2%")
            ),
            orientation="h",
            name="Average Reader's Genres",
            marker=dict(color=palette[3]),
            hovertemplate="<b>%{y}</b><br><b>Ratio:</b> %{customdata}<extra></extra>",
        ),
        row=1,
        col=1,
    )
    genre_below = genre_difference.loc[genre_difference["Result"] == "Below Average"]

    fig.add_trace(
        go.Bar(
            x=genre_below["Ratio_User"],
            y=genre_below["Shelf"],
            customdata=np.stack(
                (
                    genre_below["Ratio_User"].apply(lambda x: format(x / 100, ".2%")),
                    genre_below["titles"],
                ),
                axis=-1,
            ),
            orientation="h",
            name="Your Genres",
            marker=dict(color=palette[2]),
            hovertemplate="<b>%{y}</b><br><b>Ratio:</b> %{customdata[0]} <br><b>Titles:</b> %{customdata[1]}<extra></extra>",
            showlegend=False,
        ),
        row=1,
        col=2,
    )

    fig.add_trace(
        go.Bar(
            x=genre_below["Ratio_Total"],
            y=genre_below["Shelf"],
            customdata=genre_below["Ratio_Total"].apply(
                lambda x: format(x / 100, ".2%")
            ),
            orientation="h",
            name="Average Reader's Genres",
            marker=dict(color=palette[3]),
            hovertemplate="<b>%{y}</b><br><b>Ratio:</b> %{customdata}<extra></extra>",
            showlegend=False,
        ),
        row=1,
        col=2,
    )

    fig.update_layout(
        title=f"Genre Comparison for {username}",
        legend=dict(yanchor="top", y=-0.1, xanchor="center", x=0.5, orientation="h"),
    )
    fig.update_layout(standard_layout)
    fig.update_xaxes(showline=True, linecolor="rgb(36,36,36)")
    fig.update_yaxes(showline=True, linecolor="rgb(36,36,36)")

    return fig


def summary_plot(
    df,
    username,
    date_col="original_publication_year",
    start_year=1800,
    gender_col="gender",
    narrative_col="narrative",
    pages_col="number_of_pages",
    title_col="title_simple",
    my_rating_col="my_rating",
    n_shelves=4,
    min_count=3,
):
    """
    Call 4 distinct plot generators. Load them up into a 2x2 grid. Save and return figure.
    """
    fig = make_subplots(
        rows=2,
        cols=2,
        subplot_titles=(
            "Gender Summary",
            "Publication Dates",
            "Longest Books",
            "Genres",
        ),
        vertical_spacing=0.1,
    )

    gender_traces = gender_bar_plot(
        df, gender_col=gender_col, narrative_col=narrative_col
    )
    for trace in gender_traces:
        fig.add_trace(trace, row=1, col=1)

    fig.add_trace(
        publication_histogram(
            df, date_col=date_col, title_col=title_col, start_year=start_year
        ),
        row=1,
        col=2,
    )

    fig.add_trace(
        plot_longest_books(df, pages_col=pages_col, title_col=title_col),
        row=2,
        col=1,
    )

    fig.add_trace(
        genre_bar_plot(df, n_shelves=n_shelves, min_count=min_count), row=2, col=2
    )
    fig.update_layout(title=f"Summary - {username}")
    fig.update_layout(standard_layout)
    fig.update_xaxes(showline=True, linecolor="rgb(36,36,36)")
    fig.update_yaxes(showline=True, linecolor="rgb(36,36,36)")

    return fig


def load_map():
    world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))
    return world


def load_nationality_dict():
    region_df = objects_to_df(RefNationality.objects.all())
    if len(region_df) == 0:
        logger.error("No region data queried")
    country_mapper = {
        "England": "United Kingdom",
        "Bosnia": "Bosnia and Herz.",
        "Dominican Republic": "Dominican Rep.",
        "South Sudan": "S. Sudan",
        "Central African Republic": "Central African Rep.",
    }
    region_df["region"] = region_df["region"].replace(country_mapper)
    nat_dict = region_df.set_index("nationality").to_dict()["region"]
    return nat_dict


def join_titles(titles, limit=3):
    return ", ".join(titles[: min(len(titles), limit)])


def return_nationality_count(
    df,
    nationality_col="nationality_chosen",
    title_col="title_simple",
    author_col="author",
    limit=3,
):
    nat_dict = load_nationality_dict()
    df["region"] = df[nationality_col].map(nat_dict)
    nationality_count = (
        pd.pivot_table(
            df,
            index="region",
            values=[title_col, author_col],
            aggfunc=[len, lambda x: join_titles(x, limit)],
        )
        .reindex(columns=[title_col, author_col], level=1)
        .reset_index()
    )
    nationality_count.columns = [
        "region",
        "count",
        "count2",
        title_col,
        author_col,
    ]

    return nationality_count


def merge_map_data(world_df, nationality_count, nationality_col="region"):
    if len(world_df) == 0:
        return world_df
    world_df = pd.merge(
        world_df,
        nationality_count,
        how="left",
        left_on="name",
        right_on=nationality_col,
    )
    logger.info(
        f"Map data merged with {len(pd.unique(nationality_count[nationality_col]))} unique nationalities"
    )
    return world_df


def bokeh_world_plot(world_df, username):
    from bokeh.plotting import figure, output_file, save
    from bokeh.models import (
        ColorBar,
        GeoJSONDataSource,
        HoverTool,
        LogColorMapper,
    )
    from bokeh.palettes import brewer

    output_file(
        filename=f"goodreads/static/Graphs/{username}/author_map_{username}.html",
        title=f"Author Map - {username}",
    )
    heat_palette = brewer["OrRd"][8]
    heat_palette = heat_palette[
        ::-1
    ]  # reverse order of colors so higher values have darker colors
    color_mapper = LogColorMapper(
        palette=heat_palette, low=1, high=world_df["count"].max()
    )
    # Create color bar.
    color_bar = ColorBar(
        color_mapper=color_mapper,
        label_standoff=8,
        width=500,
        height=20,
        border_line_color=None,
        location=(0, 0),
        orientation="horizontal",
        # major_label_overrides = tick_labels
    )
    p = figure(
        title=f"Author Nationality Map - {username}",
        width=900,
        height=750,
        align="center",
        toolbar_location="below",
        tools="pan, wheel_zoom, box_zoom, reset",
        sizing_mode="scale_width",
    )
    # Add patch renderer to figure.
    geosource = GeoJSONDataSource(geojson=world_df.to_json())
    author_map = p.patches(
        "xs",
        "ys",
        source=geosource,
        fill_color={"field": "count", "transform": color_mapper},
        line_color="gray",
        line_width=0.25,
        fill_alpha=1,
    )
    # Create hover tool
    p.add_tools(
        HoverTool(
            renderers=[author_map],
            tooltips=[
                ("Country", "@name"),
                ("Author Count", "@count"),
                ("Titles", "@title_simple"),
                ("Authors", "@author"),
            ],
        )
    )

    p.add_layout(color_bar, "below")
    p.min_border = 0
    p.title.align = "center"
    save(p)


def return_small_nationalities(df, nationality_col="nationality_chosen"):
    small = [
        "Hong Kong",
        "Hong Konger",
        "Fijian",
        "Bahamanian",
        "East Timorese",
        "El Salvadoran",
        "Belizean",
        "Puerto Rican",
        "Jamaican",
        "Lebanese",
        "Palestinian",
        "Gambian",
        "Qatari",
        "Kuwaiti",
        "Vanuatuan",
        "Luxembourgish",
        "Bruneian",
        "Cypriot",
        "Djiboutian",
        "Rwandan",
        "Montenegrin",
        "Kosovar",
        "Singaporean",
        "Costa Rican",
    ]
    return df.loc[df[nationality_col].isin(small)]


def write_small_nationalities(df):
    if len(df) < 0:
        return None
    else:
        df_write = df[["author", "nationality_chosen"]].drop_duplicates()
        output = "In addition, you have read authors from small places that might not be visible on the map. This includes:"
        for i, row in df_write.iterrows():
            output += (
                f"<br><b>{row['nationality_chosen']}</b> author <i>{row['author']}</i>"
            )
        return output


def create_read_plot_heatmap(
    df,
    username,
    heat_col="read",
    title_col="title_simple",
    min_break=3,
    date_col="date_read",
    start_year=None,
    lim=40,
    colorscale="Plotly3",
):
    df = read_plot_munge(
        df,
        read_col=heat_col,
        min_break=min_break,
        date_col=date_col,
        start_year=start_year,
    )
    strats = pd.unique(df["strats"])
    strats = strats[
        pd.notnull(strats)
    ]  # occasionally goodreads has errors and returns negative readers
    df["narrative_int"] = df["narrative"].map({"Fiction": 1, "Nonfiction": 0})
    df["hover_text"] = df.apply(
        lambda x: f"<b>Readers:</b> {'{:,.0f}'.format(x.read)}<br><b>Title:</b> {x.title_simple} <br><b>Author:</b> {x.author}",
        axis=1,
    )
    fig = make_subplots(
        rows=1,
        cols=len(strats),
        horizontal_spacing=0.025,
    )

    for i in range(len(strats)):
        r_strat = df[df["strats"] == strats[i]].tail(lim)
        heatmap = ff.create_annotated_heatmap(
            x=[strats[i]],
            z=[[r] for r in r_strat["narrative_int"]],
            annotation_text=[[r] for r in r_strat[title_col]],
            text=[[r] for r in r_strat["hover_text"]],
            opacity=(i + 1) / len(strats),
            hoverinfo="text",
            colorscale=colorscale,
            ygap=1,
        )

        fig.add_trace(heatmap.data[0], row=1, col=i + 1)
        annotations = heatmap.layout.annotations
        for k in range(len(annotations)):
            annotations[k]["xref"] = f"x{i + 1}"
            annotations[k]["yref"] = f"y{i + 1}"
            fig.add_annotation(annotations[k])

        if i == 0:
            fig.update_layout(yaxis=dict(visible=False, categoryorder="array"))
        else:
            fig.layout[f"yaxis{i + 1}"] = dict(visible=False, categoryorder="array")
    fig.update_layout(
        title=f"Popularity Spectrum - {username}",
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
    )
    fig.update_layout(standard_layout)
    fig.update_xaxes(
        showline=True,
        range=[-0.5, 0.5],
        linecolor="rgb(36,36,36)",
        tickfont=dict(color="#636efa"),
    )
    fill = getattr(px.colors.sequential, colorscale)
    # Custom legend
    fig.add_shape(
        type="rect",
        xref="paper",
        yref="paper",
        fillcolor=fill[0],
        x0=0.2,
        y0=-0.05,
        x1=0.4,
        y1=-0.15,
    )
    fig.add_annotation(
        text="<b>Non-Fiction</b>",
        xref="paper",
        yref="paper",
        x=0.3,
        y=-0.1,
        showarrow=False,
        xanchor="center",
        yanchor="middle",
        font=dict(color="white"),
    )

    fig.add_shape(
        type="rect",
        xref="paper",
        yref="paper",
        fillcolor=fill[-1],
        x0=0.6,
        y0=-0.05,
        x1=0.8,
        y1=-0.15,
    )
    fig.add_annotation(
        text="<b>Fiction</b>",
        xref="paper",
        yref="paper",
        x=0.7,
        y=-0.1,
        showarrow=False,
        xanchor="center",
        yanchor="middle",
        font=dict(color="white"),
    )

    filename = (
        f"goodreads/static/Graphs/{username}/goodreads_read_heatmap_{username}.html"
    )
    fig.write_html(file=filename)
    return fig


def format_month_plot(df, date_col):
    df["year_read"] = df[date_col].dt.year
    df["month_read"] = df[date_col].dt.month
    logger.info(
        f"Starting Monthly pages read plot for data with \
        years {df['year_read'].unique()}"
    )
    df = df[pd.notnull(df["year_read"])]
    return df


def month_plot(
    df, username, date_col, page_col, title_col, author_gender_col, lims=None
):
    df = df.copy()
    df = format_month_plot(df, date_col=date_col)
    if lims is not None:
        df = df[(df["year_read"] >= lims[0]) & (df["year_read"] <= lims[1])]
    n_years = len(pd.unique(df["year_read"]))
    if n_years < 1:
        logger.info("Not enough date data to plot month plot")
        fig = go.Figure()
        fig.add_trace(
            go.Bar(
                x=[0, 0],
                y=[0, 1],
                text="Not Enough Data with Date Read Inputted to Plot",
                width=5,
            )
        )
        return fig

    df["color"] = df[author_gender_col].map(
        {
            "female": palette[1],
            "male": palette[0],
            "other": palette[2],
            "non-binary": palette[3],
        }
    )
    df["text"] = df["text"] = (
        df[title_col] + "<br>" + df["author"] + "<br>" + df[date_col].astype(str)
    )
    fig = make_subplots(
        rows=n_years,
        cols=1,
        shared_xaxes=True,
        vertical_spacing=0.01,
        x_title="Month",
        y_title="Number of Pages",
    )
    for i, year in enumerate(sorted(pd.unique(df["year_read"]))):
        df_year = df[df["year_read"] == year]
        df_month_max = pd.pivot_table(
            df_year, index="month_read", values=page_col, aggfunc=sum
        )[page_col].max()
        for g in df_year[author_gender_col].unique():
            df_year_g = df_year.loc[df_year[author_gender_col] == g]
            fig.add_trace(
                go.Bar(
                    x=df_year_g["month_read"],
                    y=df_year_g[page_col],
                    marker_color=df_year_g["color"],
                    hovertext=df_year_g["text"],
                    hovertemplate="%{hovertext}<extra></extra>",
                    text=df_year_g["author"],
                    textposition="inside",
                    textangle=0,
                    textfont=dict(size=8),
                    width=1,
                    showlegend=(i + 1) == n_years,
                    name=g,
                ),
                row=i + 1,
                col=1,
            )
        # Add the year to the side, as a facet label. Set at vertical halfway mark
        fig.add_annotation(
            x=13,
            y=df_month_max / 2,
            text=str(int(year)),
            xref=f"x{i + 1}",
            yref=f"y{i + 1}",
            font=dict(color="white", size=max(5.0, 25 - n_years * 0.25)),
            bgcolor="grey",
            bordercolor="grey",
            borderwidth=1,
            showarrow=False,
        )
    fig.update_layout(
        title_text=f"Month Breakdown - {username}",
        title_x=0.5,
        barmode="stack",
        uniformtext_minsize=6,
        uniformtext_mode="hide",
        plot_bgcolor="rgba(0,0,0,0)",
        legend=dict(
            yanchor="top", y=-0.4 / n_years, xanchor="center", x=0.5, orientation="h"
        ),
    )
    fig.update_xaxes(
        tickvals=np.arange(1, 13),
        showgrid=False,
        zeroline=True,
        zerolinewidth=2,
        zerolinecolor="black",
    )
    fig.update_yaxes(zeroline=True, zerolinewidth=2, zerolinecolor="black")

    return fig


def find_narrative(row):
    # join a list of strings or None
    row_array = list(filter(None, row))
    if "Audiobook" in row_array:
        row_array.remove("Audiobook")

    narrative = "Fiction"  # Default value
    narrative_options = ["Nonfiction", "Fiction"]

    for option in narrative_options:
        if option in row_array:
            row_array.remove(option)
            narrative = option
            break

    return narrative, row_array


def genre_join(df):
    scols = [c for c in df.columns if c.startswith("shelf")]

    genre_returns = df[scols].apply(find_narrative, axis=1)
    df["narrative"] = [g[0] for g in genre_returns]
    df["shelves"] = [g[1] for g in genre_returns]
    return df


def main(username):
    df = load_data(username)
    logger.info(f"Data read with {len(df)} rows \n : {df.head()}")
    df = run_all(df)
    read_df = df[
        df["exclusive_shelf"] == "read"
    ]  # ignore the books that haven't been read
    try:
        fig_summary = summary_plot(read_df, username)
        save_fig(
            fig_summary,
            f"goodreads/static/Graphs/{username}/goodreads_summary_{username}.html",
        )
    except Exception as exception:
        logger.info(" summary plot failed: " + str(exception))

    try:
        create_read_plot_heatmap(df=read_df, username=username)
    except Exception as exception:
        logger.info("reader heatmap plot failed: " + str(exception))
    fig_finish = finish_plot(df, username)
    fig_finish.write_html(
        f"goodreads/static/Graphs/{username}/goodreads_finish_plot_{username}.html"
    )
    genres_avg = pd.read_csv("artifacts/genres_avg.csv")
    genre_difference = format_genre_table(read_df, genres_avg=genres_avg, n=12)
    fig_genres = plot_genre_difference(genre_difference, username)
    save_fig(
        fig_genres,
        f"goodreads/static/Graphs/{username}/goodreads_genre_diff_{username}.html",
    )
    # world map plotting
    world_df = load_map()
    nationality_count = return_nationality_count(read_df)
    world_df = merge_map_data(world_df, nationality_count, nationality_col="region")
    bokeh_world_plot(world_df, username)

    write_text(
        filename=f"goodreads/static/Graphs/{username}/goodreads_small_{username}.txt",
        texts=[write_small_nationalities(return_small_nationalities(read_df))],
    )

    fig_month = month_plot(
        read_df,
        username,
        date_col="date_read",
        page_col="number_of_pages",
        title_col="title_simple",
        author_gender_col="gender",
        lims=[2013, 2024],
    )
    fig_month.write_html(
        f"goodreads/static/Graphs/{username}/monthly_pages_read_{username}.html"
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--username",
        dest="username",
        help="The username which data is queried from goodreads.exportbooks",
    )
    args = parser.parse_args()
    username = args.username
    main(username)
